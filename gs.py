# -*- coding: utf-8 -*-
"""GS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UNZLqlmuqkUSV1xbPPLPyRPn_zYdW6SC
"""

import random
import time

# --- Par√¢metros Globais do Sistema (Simulados) ---
# Estes valores seriam idealmente calibrados ou configurados para um local espec√≠fico.
# Baseado no exemplo do relat√≥rio para o Arduino.
ALTURA_TOTAL_RESERVATORIO_CM = 100.0  # Altura total em cm do local monitorado (ex: bueiro, c√≥rrego)
LIMIAR_ATENCAO_PERCENT = 0.30       # 30% do n√≠vel para estado de Aten√ß√£o
LIMIAR_CRITICO_PERCENT = 0.70       # 70% do n√≠vel para estado Cr√≠tico

# Dados simulados para o sensor (representa o n√≠vel da √°gua em cm)
# Pode ser uma progress√£o para simular uma enchente
DADOS_SENSOR_SIMULADOS = [
    5.0, 10.0, 15.0, 20.0, 25.0, # Seguro
    30.0, 35.0, 40.0, 50.0, 60.0, 69.0, # Aten√ß√£o
    70.0, 75.0, 85.0, 95.0, # Cr√≠tico
    105.0, # Erro (n√≠vel acima da altura total, indicando poss√≠vel falha ou situa√ß√£o extrema)
    -5.0, # Erro (leitura inv√°lida do sensor)
    10.0 # Retorno ao normal
]
indice_leitura_sensor = 0

def validar_entrada_texto_obrigatorio(prompt_usuario, tamanho_max=150):
    """
    Solicita uma entrada de texto do usu√°rio e garante que n√£o seja vazia.

    Args:
        prompt_usuario (str): A mensagem a ser exibida para o usu√°rio.
        tamanho_max (int): Tamanho m√°ximo permitido para a entrada.

    Returns:
        str: O texto de entrada validado.
    """
    while True:
        entrada = input(prompt_usuario).strip()
        if not entrada:
            exibir_mensagem_console("Esta informa√ß√£o √© obrigat√≥ria. Por favor, tente novamente.", "ERRO")
        elif len(entrada) > tamanho_max:
            exibir_mensagem_console(f"O texto n√£o pode exceder {tamanho_max} caracteres. Por favor, tente novamente.", "ERRO")
        else:
            return entrada

def validar_opcao_lista(prompt_usuario, opcoes_validas):
    """
    Solicita ao usu√°rio que escolha uma op√ß√£o de uma lista v√°lida.

    Args:
        prompt_usuario (str): A mensagem a ser exibida.
        opcoes_validas (dict): Um dicion√°rio onde as chaves s√£o as entradas do usu√°rio
                               e os valores s√£o as descri√ß√µes das op√ß√µes.

    Returns:
        str: A chave da op√ß√£o v√°lida escolhida pelo usu√°rio.
    """
    print(prompt_usuario)
    for chave, descricao in opcoes_validas.items():
        print(f"  {chave}) {descricao}")

    while True:
        escolha = input("Digite sua op√ß√£o: ").lower()
        if escolha in opcoes_validas:
            return escolha
        else:
            exibir_mensagem_console(f"Op√ß√£o inv√°lida. Por favor, escolha entre: {', '.join(opcoes_validas.keys())}.", "ERRO")

def ler_dados_sensor_simulado(sensor_id="principal"):
    """
    Simula a leitura de um sensor de n√≠vel de √°gua.
    Cicla atrav√©s da lista DADOS_SENSOR_SIMULADOS.

    Args:
        sensor_id (str): Identificador do sensor (para futuras expans√µes).

    Returns:
        float: O n√≠vel da √°gua simulado em cm, ou -1.0 para simular um erro de leitura.
    """
    global indice_leitura_sensor
    if not DADOS_SENSOR_SIMULADOS:
        # Se n√£o houver dados, simula uma leitura aleat√≥ria est√°vel ou com pequena varia√ß√£o
        return round(random.uniform(5.0, 25.0), 1)

    nivel_simulado = DADOS_SENSOR_SIMULADOS[indice_leitura_sensor]
    indice_leitura_sensor = (indice_leitura_sensor + 1) % len(DADOS_SENSOR_SIMULADOS) # Cicla na lista

    # Simula um pequeno atraso, como se fosse uma leitura real
    time.sleep(0.5)
    return nivel_simulado

def calcular_status_alerta_sensor(nivel_agua_cm, altura_total_cm, limiar_atencao_p, limiar_critico_p):
    """
    Calcula o status do alerta com base no n√≠vel da √°gua e nos limiares.

    Args:
        nivel_agua_cm (float): N√≠vel atual da √°gua em cm.
        altura_total_cm (float): Altura total do reservat√≥rio/local em cm.
        limiar_atencao_p (float): Percentual para alerta de aten√ß√£o (ex: 0.30 para 30%).
        limiar_critico_p (float): Percentual para alerta cr√≠tico (ex: 0.70 para 70%).

    Returns:
        str: O status do alerta ("Seguro", "Aten√ß√£o", "Cr√≠tico", "Falha Sensor").
    """
    if nivel_agua_cm < 0 or nivel_agua_cm > (altura_total_cm + altura_total_cm * 0.1) : # Considera uma margem de erro acima da altura total
        return "Falha Sensor"

    nivel_atencao_abs = altura_total_cm * limiar_atencao_p
    nivel_critico_abs = altura_total_cm * limiar_critico_p

    if nivel_agua_cm >= nivel_critico_abs:
        return "Cr√≠tico"
    elif nivel_agua_cm >= nivel_atencao_abs:
        return "Aten√ß√£o"
    else:
        return "Seguro"

def coletar_relato_cidadao():
    """
    Coleta um relato de enchente do cidad√£o atrav√©s de entradas do usu√°rio.

    Returns:
        dict: Um dicion√°rio contendo as informa√ß√µes do relato
              (tipo, local, descricao), ou None se o usu√°rio cancelar.
    """
    exibir_mensagem_console("--- Registro de Nova Ocorr√™ncia Comunit√°ria ---", "DESTAQUE")

    tipos_ocorrencia_validos = {
        "1": "Alagamento de via",
        "2": "Bueiro entupido com ac√∫mulo de √°gua",
        "3": "N√≠vel de rio/c√≥rrego subindo rapidamente",
        "4": "Risco de deslizamento devido √† chuva",
        "5": "Outro tipo de ocorr√™ncia relacionada a enchentes"
    }
    tipo_escolhido_chave = validar_opcao_lista("Selecione o tipo de ocorr√™ncia:", tipos_ocorrencia_validos)
    tipo_ocorrencia_desc = tipos_ocorrencia_validos[tipo_escolhido_chave]

    local_ocorrencia = validar_entrada_texto_obrigatorio("Localiza√ß√£o da ocorr√™ncia (ex: Rua Exemplo, perto do n¬∫ 123): ")
    descricao_adicional = validar_entrada_texto_obrigatorio("Descreva brevemente a situa√ß√£o: ", tamanho_max=200)

    confirmar = input("Confirmar o envio deste relato? (s/n): ").lower()
    if confirmar == 's':
        relato = {
            "tipo": tipo_ocorrencia_desc,
            "local": local_ocorrencia,
            "descricao": descricao_adicional,
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")
        }
        return relato
    else:
        exibir_mensagem_console("Registro de ocorr√™ncia cancelado.", "INFO")
        return None

def processar_relatos_para_alerta(lista_relatos):
    """
    Processa a lista de relatos para gerar um alerta comunit√°rio (l√≥gica simplificada).
    Nesta vers√£o, qualquer relato do tipo "cr√≠tico" gera um alerta.

    Args:
        lista_relatos (list): Lista de dicion√°rios, onde cada dicion√°rio √© um relato.

    Returns:
        str or None: Mensagem de alerta comunit√°rio ou None se nenhum alerta gerado.
    """
    if not lista_relatos:
        return None

    # L√≥gica simplificada: se o √∫ltimo relato for de um tipo considerado cr√≠tico, gera alerta.
    # Tipos cr√≠ticos podem ser definidos com base na descri√ß√£o ou tipo.
    # Por exemplo, se o tipo do √∫ltimo relato cont√©m "subindo rapidamente" ou "alagamento de via"
    ultimo_relato = lista_relatos[-1] # Pega o relato mais recente
    if "subindo rapidamente" in ultimo_relato["tipo"].lower() or \
       "alagamento de via" in ultimo_relato["tipo"].lower() or \
       "risco de deslizamento" in ultimo_relato["tipo"].lower():
        return (f"Alerta Comunit√°rio Urgente: Recebido relato de '{ultimo_relato['tipo']}' "
                f"em '{ultimo_relato['local']}'. Descri√ß√£o: '{ultimo_relato['descricao']}'. "
                f"Recomenda-se precau√ß√£o na √°rea!")
    return None

def exibir_mensagem_console(mensagem, tipo="INFO"):
    """
    Exibe uma mensagem formatada no console.

    Args:
        mensagem (str): A mensagem a ser exibida.
        tipo (str): O tipo da mensagem ("INFO", "ALERTA", "ERRO", "DESTAQUE").
    """
    if tipo == "ALERTA":
        print(f"[ALERTA üî¥] {mensagem}")
    elif tipo == "ERRO":
        print(f"[ERRO ‚ùå] {mensagem}")
    elif tipo == "DESTAQUE":
        print(f"\n--- {mensagem} ---\n")
    else: # INFO
        print(f"[INFO ‚ÑπÔ∏è] {mensagem}")

def main_loop_simulador():
    """
    Loop principal do simulador do sistema de alerta.
    """
    exibir_mensagem_console("Iniciando Simulador do Sistema de Alerta Cidad√£o Conectado", "DESTAQUE")

    historico_relatos_comunitarios = []
    ciclo_atual = 1

    while True:
        exibir_mensagem_console(f"Iniciando Ciclo de Monitoramento n¬∫ {ciclo_atual}", "DESTAQUE")

        # 1. Ler dados do sensor simulado
        nivel_agua_atual_cm = ler_dados_sensor_simulado()
        exibir_mensagem_console(f"Sensor 'Rio Principal' - Leitura N√≠vel √Ågua: {nivel_agua_atual_cm:.2f} cm (de {ALTURA_TOTAL_RESERVATORIO_CM:.1f} cm)")

        # 2. Calcular status de alerta do sensor
        status_alerta_do_sensor = calcular_status_alerta_sensor(
            nivel_agua_atual_cm,
            ALTURA_TOTAL_RESERVATORIO_CM,
            LIMIAR_ATENCAO_PERCENT,
            LIMIAR_CRITICO_PERCENT
        )
        exibir_mensagem_console(f"Status do Sistema (baseado no sensor): {status_alerta_do_sensor}", "ALERTA" if status_alerta_do_sensor != "Seguro" else "INFO")

        # 3. Perguntar se o usu√°rio deseja registrar uma ocorr√™ncia
        if input("Deseja registrar uma ocorr√™ncia comunit√°ria neste ciclo? (s/n): ").lower() == 's':
            novo_relato = coletar_relato_cidadao()
            if novo_relato:
                historico_relatos_comunitarios.append(novo_relato)
                exibir_mensagem_console("Relato comunit√°rio adicionado com sucesso!", "INFO")

                # 4. Processar relatos para gerar um alerta comunit√°rio (se houver)
                alerta_baseado_em_relatos = processar_relatos_para_alerta(historico_relatos_comunitarios)
                if alerta_baseado_em_relatos:
                    exibir_mensagem_console(alerta_baseado_em_relatos, "ALERTA")
            else:
                exibir_mensagem_console("Nenhum relato comunit√°rio foi adicionado neste ciclo.", "INFO")

        # 5. Perguntar se deseja continuar para o pr√≥ximo ciclo
        if input("\nContinuar para o pr√≥ximo ciclo de monitoramento? (s/n): ").lower() != 's':
            break

        ciclo_atual += 1
        print("-" * 50) # Separador visual

    exibir_mensagem_console("Simulador encerrado pelo usu√°rio.", "DESTAQUE")

# --- Ponto de Entrada do Script ---
if __name__ == "__main__":
    main_loop_simulador()